#summary Our function hashing

= C =
{{{
 #include <sys/types.h>
 #include <iostream>
 #include <fstream>
 
 using namespace std;
 
 #define MAX(x,y) (((x) > (y)) ? (x) : (y))
 
 uint64_t compute_hash(ifstream& f)
 {
 uint64_t hash, fsize;
 
 f.seekg(0, ios::end);
 fsize = f.tellg();
 f.seekg(0, ios::beg);
 
 hash = fsize;
 for(uint64_t tmp = 0, i = 0; i < 65536/sizeof(tmp) && f.read((char*)&tmp, sizeof(tmp)); hash += tmp, i++);
 f.seekg(MAX(0, (uint64_t)fsize - 65536), ios::beg);
 for(uint64_t tmp = 0, i = 0; i < 65536/sizeof(tmp) && f.read((char*)&tmp, sizeof(tmp)); hash += tmp, i++);
 return hash;
 }
 
 int main(int argc, char *argv)
 {
 ifstream f;
 uint64_t myhash;
 
 f.open("myfile.txt", ios::in|ios::binary|ios::ate);
 if (!f.is_open()) {
    cerr << "Error opening file" << endl;
    return 1;
 }
 
 myhash = compute_hash(f);
 cout << "Hash is " << myhash << endl;
 
 f.close();
 return 0;
 }
}}}


= C++ =
{{{
 #include <iostream>
 #include <fstream> 
 
 typedef unsigned __int64 uint64_t;
 using namespace std;
 
 int MAX(int x, int y)
 {  
 	if((x) > (y)) 
 		return x;
 	else	
 		return y;
 }
 
 uint64_t compute_hash(ifstream& f)
 {
 	uint64_t hash, fsize;
 
 	f.seekg(0, ios::end);
 	fsize = f.tellg();
 	f.seekg(0, ios::beg);
 
 	hash = fsize;
 	for(uint64_t tmp = 0, i = 0; i < 65536/sizeof(tmp) && f.read((char*)&tmp, sizeof(tmp)); i++, hash += tmp);
 	f.seekg(MAX(0, (uint64_t)fsize - 65536), ios::beg);
 	for(tmp = 0, i = 0; i < 65536/sizeof(tmp) && f.read((char*)&tmp, sizeof(tmp)); i++, hash += tmp);
 	return hash;
 } 
 
 int main(int argc, char *argv)
 {
 	ifstream f;
 	uint64_t myhash;
 
 	f.open("c:\\test.avi", ios::in|ios::binary|ios::ate);
 	if (!f.is_open()) {
 	   cerr << "Error opening file" << endl;
 	   return 1;
 	}
 
 	myhash = compute_hash(f);
 	
 	printf("%I64x", myhash);
 
 	f.close();
 	return 0;
 }

}}}

= Python =
{{{
def hashFile(name): 
      try: 
   		 
                longlongformat = 'LL'  # signed long, unsigned long 
                bytesize = struct.calcsize(longlongformat) 
                    
                f = file(name, "rb") 
                    
                filesize = os.path.getsize(name) 
                hash = filesize 
                    
                if filesize < 65536 * 2: 
                       return "SizeError" 
     		 
                for x in range(65536/bytesize): 
                        buffer = f.read(bytesize) 
                        (l2, l1)= struct.unpack(longlongformat, buffer) 
                        l_value = (long(l1) << 32) | long(l2) 
                        hash += l_value 
                        hash = hash & 0xFFFFFFFFFFFFFFFF #to remain as 64bit number  
   			 
    
                f.seek(max(0,filesize-65536),0) 
                for x in range(65536/bytesize): 
                        buffer = f.read(bytesize) 
                        (l2, l1) = struct.unpack(longlongformat, buffer) 
                        l_value = (long(l1) << 32) | long(l2) 
                        hash += l_value 
                        hash = hash & 0xFFFFFFFFFFFFFFFF 
                 
                f.close() 
                returnedhash =  "%016x" % hash 
                return returnedhash 
    
      except(IOError): 
                return "IOError"
}}}
= C# =
{{{
using System;
using System.Text;
using System.IO;
   
namespace MovieHasher
{
    class Program
    {
        private static byte[] ComputeMovieHash(string filename)
        {
            byte[] result;
            using (Stream input = File.OpenRead(filename))
            {
                result = ComputeMovieHash(input);
            }
            return result;
        }
 
        private static byte[] ComputeMovieHash(Stream input)
        {
            long lhash, streamsize;
            streamsize = input.Length;
            lhash = streamsize;
 
            long i = 0;
            byte[] buffer = new byte[sizeof(long)];
            while (i < 65536 / sizeof(long) && (input.Read(buffer, 0, sizeof(long)) > 0))
            {
                i++;
                lhash += BitConverter.ToInt64(buffer, 0);
            }
 
            input.Position = Math.Max(0, streamsize - 65536);
            i = 0;
            while (i < 65536 / sizeof(long) && (input.Read(buffer, 0, sizeof(long)) > 0))
            {
                i++;
                lhash += BitConverter.ToInt64(buffer, 0);
            }
            input.Close();
            byte[] result = BitConverter.GetBytes(lhash);
            Array.Reverse(result);
            return result;
        }
 
        private static string ToHexadecimal(byte[] bytes)
        {
            StringBuilder hexBuilder = new StringBuilder();
            for(int i = 0; i < bytes.Length; i++)
            {
                hexBuilder.Append(bytes[i].ToString("x2"));
            }
            return hexBuilder.ToString();
        }
 
        static void Main(string[] args)
        {
            byte[] moviehash = ComputeMovieHash(@"C:\test.avi");
            Console.WriteLine("The hash of the movie-file is: {0}", ToHexadecimal(moviehash));
        }
    }
}
}}}

= Delphi =
This is just a quick conversion of Gabest's original C code. Anyone who can come up with a cleaner code, please feel free to do so and post here.

{{{
function CalcGabestHash(const fname: string): string;
var
  i : integer;
  f : file;
  s : array[1..8] of char;
  tmp : Int64 absolute s;
  hash : Int64;
  readed : integer;
  OldFM : byte;
begin
  result := '';
  OldFM := FileMode;
  if not FileExists(fname) then
    exit;

  FileMode := fmShareDenyNone;
  AssignFile(f, fname);
  Reset(f,1);
  readed := 1;
  i:=0;
  hash := filesize(f);
  while ((i<8192) and (readed > 0)) do begin
    blockread(f, s, sizeof(s), readed);
    if readed>0 then
      hash := hash + tmp;
    i:=i+1;
  end;

  seek(f, max(0, filesize(f)-65536));
  i:=0;
  readed:=1;
  while ((i<8192) and (readed > 0)) do begin
    blockread(f, s, sizeof(s), readed);
    if readed>0 then
      hash := hash + tmp;
    i:=i+1;
  end;

  CloseFile(F);
  result := Format('%.16x',[hash]);
  FileMode := OldFM;
end;
}}}